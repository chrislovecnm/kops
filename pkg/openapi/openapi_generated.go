// +build !ignore_autogenerated

/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by openapi-gen. Do not edit it manually!

package openapi

import (
	spec "github.com/go-openapi/spec"
	openapi "k8s.io/apimachinery/pkg/openapi"
)

func GetOpenAPIDefinitions(ref openapi.ReferenceCallback) map[string]openapi.OpenAPIDefinition {
	return map[string]openapi.OpenAPIDefinition{
		"k8s.io/kops/pkg/apis/kops/v1alpha2.AccessSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"dns": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.DNSAccessSpec"),
							},
						},
						"loadBalancer": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.LoadBalancerAccessSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha2.DNSAccessSpec", "k8s.io/kops/pkg/apis/kops/v1alpha2.LoadBalancerAccessSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.AlwaysAllowAuthorizationSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.AuthenticationSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"kopeio": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.KopeioAuthenticationSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha2.KopeioAuthenticationSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.AuthorizationSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"alwaysAllow": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.AlwaysAllowAuthorizationSpec"),
							},
						},
						"rbac": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.RBACAuthorizationSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha2.AlwaysAllowAuthorizationSpec", "k8s.io/kops/pkg/apis/kops/v1alpha2.RBACAuthorizationSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.BastionSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"bastionPublicName": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"idleTimeoutSeconds": {
							SchemaProps: spec.SchemaProps{
								Description: "IdleTimeoutSeconds is the bastion's Loadbalancer idle timeout",
								Type:        []string{"integer"},
								Format:      "int64",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.CNINetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "CNI is the specification for networking that is implemented by a Daemonset Networking is not managed by kops - we can create options here that directly configure e.g. weave but this is useful for arbitrary network modes or for modes that don't need additional configuration.",
					Properties:  map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.CalicoNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "Calico declares that we want Calico networking",
					Properties: map[string]spec.Schema{
						"crossSubnet": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.CanalNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "Canal declares that we want Canal networking",
					Properties:  map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.ClassicNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "ClassicNetworkingSpec is the specification of classic networking mode, integrated into kubernetes",
					Properties:  map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.CloudConfiguration": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"multizone": {
							SchemaProps: spec.SchemaProps{
								Description: "GCE cloud-config options",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"nodeTags": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"nodeInstancePrefix": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"disableSecurityGroupIngress": {
							SchemaProps: spec.SchemaProps{
								Description: "AWS cloud-config options",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"elbSecurityGroup": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"vSphereUsername": {
							SchemaProps: spec.SchemaProps{
								Description: "vSphere cloud-config specs",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"vSpherePassword": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"vSphereServer": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"vSphereDatacenter": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"vSphereDatastore": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"vSphereResourcePool": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"vSphereCoreDNSServer": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.Cluster": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"kind": {
							SchemaProps: spec.SchemaProps{
								Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"apiVersion": {
							SchemaProps: spec.SchemaProps{
								Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"metadata": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
							},
						},
						"spec": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.ClusterSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "k8s.io/kops/pkg/apis/kops/v1alpha2.ClusterSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.ClusterList": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"kind": {
							SchemaProps: spec.SchemaProps{
								Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"apiVersion": {
							SchemaProps: spec.SchemaProps{
								Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"metadata": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
							},
						},
						"items": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.Cluster"),
										},
									},
								},
							},
						},
					},
					Required: []string{"items"},
				},
			},
			Dependencies: []string{
				"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "k8s.io/kops/pkg/apis/kops/v1alpha2.Cluster"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.ClusterSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"channel": {
							SchemaProps: spec.SchemaProps{
								Description: "The Channel we are following",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"configBase": {
							SchemaProps: spec.SchemaProps{
								Description: "ConfigBase is the path where we store configuration for the cluster This might be different that the location when the cluster spec itself is stored, both because this must be accessible to the cluster, and because it might be on a different cloud or storage system (etcd vs S3)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"cloudProvider": {
							SchemaProps: spec.SchemaProps{
								Description: "The CloudProvider to use (aws or gce)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"kubernetesVersion": {
							SchemaProps: spec.SchemaProps{
								Description: "The version of kubernetes to install (optional, and can be a \"spec\" like stable)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"subnets": {
							SchemaProps: spec.SchemaProps{
								Description: "Configuration of subnets we are targeting",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.ClusterSubnetSpec"),
										},
									},
								},
							},
						},
						"project": {
							SchemaProps: spec.SchemaProps{
								Description: "Project is the cloud project we should use, required on GCE",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"masterPublicName": {
							SchemaProps: spec.SchemaProps{
								Description: "MasterPublicName is the external DNS name for the master nodes",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"masterInternalName": {
							SchemaProps: spec.SchemaProps{
								Description: "MasterInternalName is the internal DNS name for the master nodes",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"networkCIDR": {
							SchemaProps: spec.SchemaProps{
								Description: "The CIDR used for the AWS VPC / GCE Network, or otherwise allocated to k8s This is a real CIDR, not the internal k8s network",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"networkID": {
							SchemaProps: spec.SchemaProps{
								Description: "NetworkID is an identifier of a network, if we want to reuse/share an existing network (e.g. an AWS VPC)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"topology": {
							SchemaProps: spec.SchemaProps{
								Description: "Topology defines the type of network topology to use on the cluster - default public This is heavily weighted towards AWS for the time being, but should also be agnostic enough to port out to GCE later if needed",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha2.TopologySpec"),
							},
						},
						"secretStore": {
							SchemaProps: spec.SchemaProps{
								Description: "SecretStore is the VFS path to where secrets are stored",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"keyStore": {
							SchemaProps: spec.SchemaProps{
								Description: "KeyStore is the VFS path to where SSL keys and certificates are stored",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"configStore": {
							SchemaProps: spec.SchemaProps{
								Description: "ConfigStore is the VFS path to where the configuration (Cluster, InstanceGroups etc) is stored",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"dnsZone": {
							SchemaProps: spec.SchemaProps{
								Description: "DNSZone is the DNS zone we should use when configuring DNS This is because some clouds let us define a managed zone foo.bar, and then have kubernetes.dev.foo.bar, without needing to define dev.foo.bar as a hosted zone. DNSZone will probably be a suffix of the MasterPublicName and MasterInternalName Note that DNSZone can either by the host name of the zone (containing dots), or can be an identifier for the zone.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"clusterDNSDomain": {
							SchemaProps: spec.SchemaProps{
								Description: "ClusterDNSDomain is the suffix we use for internal DNS names (normally cluster.local)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"serviceClusterIPRange": {
							SchemaProps: spec.SchemaProps{
								Description: "ServiceClusterIPRange is the CIDR, from the internal network, where we allocate IPs for services",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"nonMasqueradeCIDR": {
							SchemaProps: spec.SchemaProps{
								Description: "NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live) It cannot overlap ServiceClusterIPRange",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"sshAccess": {
							SchemaProps: spec.SchemaProps{
								Description: "SSHAccess determines the permitted access to SSH Currently only a single CIDR is supported (though a richer grammar could be added in future)",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"kubernetesApiAccess": {
							SchemaProps: spec.SchemaProps{
								Description: "KubernetesAPIAccess determines the permitted access to the API endpoints (master HTTPS) Currently only a single CIDR is supported (though a richer grammar could be added in future)",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"isolateMasters": {
							SchemaProps: spec.SchemaProps{
								Description: "IsolatesMasters determines whether we should lock down masters so that they are not on the pod network. true is the kube-up behaviour, but it is very surprising: it means that daemonsets only work on the master if they have hostNetwork=true. false is now the default, and it will:\n * give the master a normal PodCIDR\n * run kube-proxy on the master\n * enable debugging handlers on the master, so kubectl logs works",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"updatePolicy": {
							SchemaProps: spec.SchemaProps{
								Description: "UpdatePolicy determines the policy for applying upgrades automatically. Valid values:\n  'external' do not apply updates automatically - they are applied manually or by an external system\n  missing: default policy (currently OS security upgrades that do not require a reboot)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"additionalPolicies": {
							SchemaProps: spec.SchemaProps{
								Description: "Additional policies to add for roles",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"etcdClusters": {
							SchemaProps: spec.SchemaProps{
								Description: "EtcdClusters stores the configuration for each cluster",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Ref: ref("*k8s.io/kops/pkg/apis/kops/v1alpha2.EtcdClusterSpec"),
										},
									},
								},
							},
						},
						"docker": {
							SchemaProps: spec.SchemaProps{
								Description: "Component configurations",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha2.DockerConfig"),
							},
						},
						"kubeDNS": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.KubeDNSConfig"),
							},
						},
						"kubeAPIServer": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.KubeAPIServerConfig"),
							},
						},
						"kubeControllerManager": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.KubeControllerManagerConfig"),
							},
						},
						"kubeScheduler": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.KubeSchedulerConfig"),
							},
						},
						"kubeProxy": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.KubeProxyConfig"),
							},
						},
						"kubelet": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.KubeletConfigSpec"),
							},
						},
						"masterKubelet": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.KubeletConfigSpec"),
							},
						},
						"cloudConfig": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.CloudConfiguration"),
							},
						},
						"networking": {
							SchemaProps: spec.SchemaProps{
								Description: "Networking configuration",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha2.NetworkingSpec"),
							},
						},
						"api": {
							SchemaProps: spec.SchemaProps{
								Description: "API field controls how the API is exposed outside the cluster",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha2.AccessSpec"),
							},
						},
						"authentication": {
							SchemaProps: spec.SchemaProps{
								Description: "Authentication field controls how the cluster is configured for authentication",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha2.AuthenticationSpec"),
							},
						},
						"authorization": {
							SchemaProps: spec.SchemaProps{
								Description: "Authorization field controls how the cluster is configured for authorization",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha2.AuthorizationSpec"),
							},
						},
						"cloudLabels": {
							SchemaProps: spec.SchemaProps{
								Description: "Tags for AWS resources",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"hooks": {
							SchemaProps: spec.SchemaProps{
								Description: "Hooks for custom actions e.g. on first installation",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.HookSpec"),
										},
									},
								},
							},
						},
					},
				},
			},
			Dependencies: []string{
				"*k8s.io/kops/pkg/apis/kops/v1alpha2.EtcdClusterSpec", "k8s.io/kops/pkg/apis/kops/v1alpha2.AccessSpec", "k8s.io/kops/pkg/apis/kops/v1alpha2.AuthenticationSpec", "k8s.io/kops/pkg/apis/kops/v1alpha2.AuthorizationSpec", "k8s.io/kops/pkg/apis/kops/v1alpha2.CloudConfiguration", "k8s.io/kops/pkg/apis/kops/v1alpha2.ClusterSubnetSpec", "k8s.io/kops/pkg/apis/kops/v1alpha2.DockerConfig", "k8s.io/kops/pkg/apis/kops/v1alpha2.HookSpec", "k8s.io/kops/pkg/apis/kops/v1alpha2.KubeAPIServerConfig", "k8s.io/kops/pkg/apis/kops/v1alpha2.KubeControllerManagerConfig", "k8s.io/kops/pkg/apis/kops/v1alpha2.KubeDNSConfig", "k8s.io/kops/pkg/apis/kops/v1alpha2.KubeProxyConfig", "k8s.io/kops/pkg/apis/kops/v1alpha2.KubeSchedulerConfig", "k8s.io/kops/pkg/apis/kops/v1alpha2.KubeletConfigSpec", "k8s.io/kops/pkg/apis/kops/v1alpha2.NetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha2.TopologySpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.ClusterSubnetSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"name": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"zone": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"cidr": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"id": {
							SchemaProps: spec.SchemaProps{
								Description: "ProviderID is the cloud provider id for the objects associated with the zone (the subnet on AWS)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"egress": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"type": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.DNSAccessSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.DNSSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"type": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.DockerConfig": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"bridge": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"logLevel": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"ipTables": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"ipMasq": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"logDriver": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"logOpt": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"storage": {
							SchemaProps: spec.SchemaProps{
								Description: "Storage maps to the docker storage flag But nodeup will also process a comma-separate list, selecting the first supported option",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"insecureRegistry": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"registryMirrors": {
							SchemaProps: spec.SchemaProps{
								Description: "Set mirrors for dockerd, benefiting cluster provisioning and image pulling",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"mtu": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int32",
							},
						},
						"bridgeIP": {
							SchemaProps: spec.SchemaProps{
								Description: "The bridge cidr (--bip) flag",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"version": {
							SchemaProps: spec.SchemaProps{
								Description: "The version of docker to install Be careful if changing this; not all docker versions are validated, and they will break in bad ways.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.EtcdClusterSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"name": {
							SchemaProps: spec.SchemaProps{
								Description: "Name is the name of the etcd cluster (main, events etc)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"etcdMembers": {
							SchemaProps: spec.SchemaProps{
								Description: "EtcdMember stores the configurations for each member of the cluster (including the data volume)",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Ref: ref("*k8s.io/kops/pkg/apis/kops/v1alpha2.EtcdMemberSpec"),
										},
									},
								},
							},
						},
					},
				},
			},
			Dependencies: []string{
				"*k8s.io/kops/pkg/apis/kops/v1alpha2.EtcdMemberSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.EtcdMemberSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"name": {
							SchemaProps: spec.SchemaProps{
								Description: "Name is the name of the member within the etcd cluster",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"instanceGroup": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"volumeType": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"volumeSize": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int32",
							},
						},
						"kmsKeyId": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"encryptedVolume": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.ExecContainerAction": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"image": {
							SchemaProps: spec.SchemaProps{
								Description: "Docker image name.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"command": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.ExternalNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "ExternalNetworkingSpec is the specification for networking that is implemented by a Daemonset It also uses kubenet",
					Properties:  map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.Federation": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "Federation represents a federated set of kubernetes clusters",
					Properties: map[string]spec.Schema{
						"kind": {
							SchemaProps: spec.SchemaProps{
								Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"apiVersion": {
							SchemaProps: spec.SchemaProps{
								Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"metadata": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
							},
						},
						"spec": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.FederationSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "k8s.io/kops/pkg/apis/kops/v1alpha2.FederationSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.FederationList": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"kind": {
							SchemaProps: spec.SchemaProps{
								Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"apiVersion": {
							SchemaProps: spec.SchemaProps{
								Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"metadata": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
							},
						},
						"items": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.Federation"),
										},
									},
								},
							},
						},
					},
					Required: []string{"items"},
				},
			},
			Dependencies: []string{
				"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "k8s.io/kops/pkg/apis/kops/v1alpha2.Federation"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.FederationSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"controllers": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"members": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"dnsName": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.FlannelNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "Flannel declares that we want Flannel networking",
					Properties:  map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.HookSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"execContainer": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.ExecContainerAction"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha2.ExecContainerAction"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.InstanceGroup": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "InstanceGroup represents a group of instances (either nodes or masters) with the same configuration",
					Properties: map[string]spec.Schema{
						"kind": {
							SchemaProps: spec.SchemaProps{
								Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"apiVersion": {
							SchemaProps: spec.SchemaProps{
								Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"metadata": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
							},
						},
						"spec": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.InstanceGroupSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "k8s.io/kops/pkg/apis/kops/v1alpha2.InstanceGroupSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.InstanceGroupList": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"kind": {
							SchemaProps: spec.SchemaProps{
								Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"apiVersion": {
							SchemaProps: spec.SchemaProps{
								Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"metadata": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
							},
						},
						"items": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.InstanceGroup"),
										},
									},
								},
							},
						},
					},
					Required: []string{"items"},
				},
			},
			Dependencies: []string{
				"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "k8s.io/kops/pkg/apis/kops/v1alpha2.InstanceGroup"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.InstanceGroupSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"role": {
							SchemaProps: spec.SchemaProps{
								Description: "Type determines the role of instances in this group: masters or nodes",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"image": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"minSize": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int32",
							},
						},
						"maxSize": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int32",
							},
						},
						"machineType": {
							SchemaProps: spec.SchemaProps{
								Description: "NodeInstancePrefix string `json:\",omitempty\"` NodeLabels         string `json:\",omitempty\"`",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"rootVolumeSize": {
							SchemaProps: spec.SchemaProps{
								Description: "RootVolumeSize is the size of the EBS root volume to use, in GB",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"rootVolumeType": {
							SchemaProps: spec.SchemaProps{
								Description: "RootVolumeType is the type of the EBS root volume to use (e.g. gp2)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"rootVolumeOptimization": {
							SchemaProps: spec.SchemaProps{
								Description: "RootVolumeOptimization enables EBS optimization for an instance",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"subnets": {
							SchemaProps: spec.SchemaProps{
								Description: "Subnets is the names of the Subnets (as specified in the Cluster) where machines in this instance group should be placed",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"maxPrice": {
							SchemaProps: spec.SchemaProps{
								Description: "MaxPrice indicates this is a spot-pricing group, with the specified value as our max-price bid",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"associatePublicIp": {
							SchemaProps: spec.SchemaProps{
								Description: "AssociatePublicIP is true if we want instances to have a public IP",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"additionalSecurityGroups": {
							SchemaProps: spec.SchemaProps{
								Description: "AdditionalSecurityGroups attaches additional security groups (e.g. i-123456)",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"cloudLabels": {
							SchemaProps: spec.SchemaProps{
								Description: "CloudLabels indicates the labels for instances in this group, at the AWS level",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"nodeLabels": {
							SchemaProps: spec.SchemaProps{
								Description: "NodeLabels indicates the kubernetes labels for nodes in this group",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"tenancy": {
							SchemaProps: spec.SchemaProps{
								Description: "Describes the tenancy of the instance group. Can be either default or dedicated. Currently only applies to AWS.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"kubelet": {
							SchemaProps: spec.SchemaProps{
								Description: "Kubelet overrides kubelet config from the ClusterSpec",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha2.KubeletConfigSpec"),
							},
						},
						"taints": {
							SchemaProps: spec.SchemaProps{
								Description: "Taints indicates the kubernetes taints for nodes in this group",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha2.KubeletConfigSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.KopeioAuthenticationSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.KopeioNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "Kopeio declares that we want Kopeio networking",
					Properties:  map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.KubeAPIServerConfig": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"pathSrvKubernetes": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"pathSrvSshproxy": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"image": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"logLevel": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int32",
							},
						},
						"cloudProvider": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"securePort": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int32",
							},
						},
						"insecurePort": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int32",
							},
						},
						"address": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"etcdServers": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"etcdServersOverrides": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"admissionControl": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"serviceClusterIPRange": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"clientCAFile": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"basicAuthFile": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"tlsCertFile": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"tlsPrivateKeyFile": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"tokenAuthFile": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"allowPrivileged": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"apiServerCount": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int32",
							},
						},
						"runtimeConfig": {
							SchemaProps: spec.SchemaProps{
								Description: "keys and values in RuntimeConfig are parsed into the `--runtime-config` parameter for KubeAPIServer, concatenated with commas. ex: `--runtime-config=key1=value1,key2=value2`. Use this to enable alpha resources on kube-apiserver",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"kubeletClientCertificate": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"kubeletClientKey": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"anonymousAuth": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"kubeletPreferredAddressTypes": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"storageBackend": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"oidcUsernameClaim": {
							SchemaProps: spec.SchemaProps{
								Description: "The OpenID claim to use as the user name. Note that claims other than the default ('sub') is not guaranteed to be unique and immutable.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"oidcGroupsClaim": {
							SchemaProps: spec.SchemaProps{
								Description: "If provided, the name of a custom OpenID Connect claim for specifying user groups. The claim value is expected to be a string or array of strings.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"oidcIssuerURL": {
							SchemaProps: spec.SchemaProps{
								Description: "The URL of the OpenID issuer, only HTTPS scheme will be accepted. If set, it will be used to verify the OIDC JSON Web Token (JWT).",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"oidcClientID": {
							SchemaProps: spec.SchemaProps{
								Description: "The client ID for the OpenID Connect client, must be set if oidc-issuer-url is set.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"oidcCAFile": {
							SchemaProps: spec.SchemaProps{
								Description: "If set, the OpenID server's certificate will be verified by one of the authorities in the oidc-ca-file otherwise the host's root CA set will be used.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"auditLogPath": {
							SchemaProps: spec.SchemaProps{
								Description: "If set, all requests coming to the apiserver will be logged to this file.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"auditLogMaxAge": {
							SchemaProps: spec.SchemaProps{
								Description: "The maximum number of days to retain old audit log files based on the timestamp encoded in their filename.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"auditLogMaxBackups": {
							SchemaProps: spec.SchemaProps{
								Description: "The maximum number of old audit log files to retain.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"auditLogMaxSize": {
							SchemaProps: spec.SchemaProps{
								Description: "The maximum size in megabytes of the audit log file before it gets rotated. Defaults to 100MB.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"authenticationTokenWebhookConfigFile": {
							SchemaProps: spec.SchemaProps{
								Description: "File with webhook configuration for token authentication in kubeconfig format. The API server will query the remote service to determine authentication for bearer tokens.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"authenticationTokenWebhookCacheTtl": {
							SchemaProps: spec.SchemaProps{
								Description: "The duration to cache responses from the webhook token authenticator. Default is 2m. (default 2m0s)",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
						"authorizationMode": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"authorizationRbacSuperUser": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.KubeControllerManagerConfig": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"master": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"logLevel": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int32",
							},
						},
						"serviceAccountPrivateKeyFile": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"image": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"pathSrvKubernetes": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"cloudProvider": {
							SchemaProps: spec.SchemaProps{
								Description: "cloudProvider is the provider for cloud services.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"clusterName": {
							SchemaProps: spec.SchemaProps{
								Description: "clusterName is the instance prefix for the cluster.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"clusterCIDR": {
							SchemaProps: spec.SchemaProps{
								Description: "clusterCIDR is CIDR Range for Pods in cluster.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"allocateNodeCIDRs": {
							SchemaProps: spec.SchemaProps{
								Description: "allocateNodeCIDRs enables CIDRs for Pods to be allocated and, if ConfigureCloudRoutes is true, to be set on the cloud provider.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"configureCloudRoutes": {
							SchemaProps: spec.SchemaProps{
								Description: "configureCloudRoutes enables CIDRs allocated with allocateNodeCIDRs to be configured on the cloud provider.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"rootCAFile": {
							SchemaProps: spec.SchemaProps{
								Description: "rootCAFile is the root certificate authority will be included in service account's token secret. This must be a valid PEM-encoded CA bundle.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"leaderElection": {
							SchemaProps: spec.SchemaProps{
								Description: "leaderElection defines the configuration of leader election client.",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha2.LeaderElectionConfiguration"),
							},
						},
						"attachDetachReconcileSyncPeriod": {
							SchemaProps: spec.SchemaProps{
								Description: "ReconcilerSyncLoopPeriod is the amount of time the reconciler sync states loop wait between successive executions. Is set to 1 min by kops by default",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
						"terminatedPodGCThreshold": {
							SchemaProps: spec.SchemaProps{
								Description: "terminatedPodGCThreshold is the number of terminated pods that can exist before the terminated pod garbage collector starts deleting terminated pods. If <= 0, the terminated pod garbage collector is disabled.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"useServiceAccountCredentials": {
							SchemaProps: spec.SchemaProps{
								Description: "UseServiceAccountCredentials controls whether we use individual service account credentials for each controller.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/apimachinery/pkg/apis/meta/v1.Duration", "k8s.io/kops/pkg/apis/kops/v1alpha2.LeaderElectionConfiguration"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.KubeDNSConfig": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"image": {
							SchemaProps: spec.SchemaProps{
								Description: "Image is the name of the docker image to run",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"replicas": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int32",
							},
						},
						"domain": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"serverIP": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.KubeProxyConfig": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"image": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"cpuRequest": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"logLevel": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int32",
							},
						},
						"hostnameOverride": {
							SchemaProps: spec.SchemaProps{
								Description: "hostnameOverride, if non-empty, will be used as the identity instead of the actual hostname. Note: We recognize some additional values:\n @aws uses the hostname from the AWS metadata service",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"master": {
							SchemaProps: spec.SchemaProps{
								Description: "master is the address of the Kubernetes API server (overrides any value in kubeconfig)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"clusterCIDR": {
							SchemaProps: spec.SchemaProps{
								Description: "clusterCIDR is the CIDR range of the pods in the cluster. It is used to bridge traffic coming from outside of the cluster. If not provided, no off-cluster bridging will be performed.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.KubeSchedulerConfig": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"master": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"logLevel": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int32",
							},
						},
						"image": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"leaderElection": {
							SchemaProps: spec.SchemaProps{
								Description: "leaderElection defines the configuration of leader election client.",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha2.LeaderElectionConfiguration"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha2.LeaderElectionConfiguration"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.KubeletConfigSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"apiServers": {
							SchemaProps: spec.SchemaProps{
								Description: "not used for clusters version 1.6 and later",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"anonymousAuth": {
							SchemaProps: spec.SchemaProps{
								Description: "AnonymousAuth chooses if you want anonymous auth on the kubelet api",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"clientCaFile": {
							SchemaProps: spec.SchemaProps{
								Description: "The client CA which the requestes for the above must be signed by",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"kubeconfigPath": {
							SchemaProps: spec.SchemaProps{
								Description: "kubeconfigPath is the path to the kubeconfig file with authorization information and API server location kops will only use this for clusters version 1.6 and later",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"requireKubeconfig": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"logLevel": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int32",
							},
						},
						"podManifestPath": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"hostnameOverride": {
							SchemaProps: spec.SchemaProps{
								Description: "hostnameOverride is the hostname used to identify the kubelet instead of the actual hostname. Note: We recognize some additional values:\n @aws uses the hostname from the AWS metadata service",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"allowPrivileged": {
							SchemaProps: spec.SchemaProps{
								Description: "allowPrivileged enables containers to request privileged mode. Defaults to false.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"enableDebuggingHandlers": {
							SchemaProps: spec.SchemaProps{
								Description: "enableDebuggingHandlers enables server endpoints for log collection and local running of containers and commands",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"clusterDomain": {
							SchemaProps: spec.SchemaProps{
								Description: "clusterDomain is the DNS domain for this cluster. If set, kubelet will configure all containers to search this domain in addition to the host's search domains.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"clusterDNS": {
							SchemaProps: spec.SchemaProps{
								Description: "clusterDNS is the IP address for a cluster DNS server.  If set, kubelet will configure all containers to use this for DNS resolution in addition to the host's DNS servers",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"networkPluginName": {
							SchemaProps: spec.SchemaProps{
								Description: "networkPluginName is the name of the network plugin to be invoked for various events in kubelet/pod lifecycle",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"cloudProvider": {
							SchemaProps: spec.SchemaProps{
								Description: "cloudProvider is the provider for cloud services.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"kubeletCgroups": {
							SchemaProps: spec.SchemaProps{
								Description: "KubeletCgroups is the absolute name of cgroups to isolate the kubelet in.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"runtimeCgroups": {
							SchemaProps: spec.SchemaProps{
								Description: "Cgroups that container runtime is expected to be isolated in.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"systemCgroups": {
							SchemaProps: spec.SchemaProps{
								Description: "SystemCgroups is absolute name of cgroups in which to place all non-kernel processes that are not already in a container. Empty for no container. Rolling back the flag requires a reboot.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"cgroupRoot": {
							SchemaProps: spec.SchemaProps{
								Description: "cgroupRoot is the root cgroup to use for pods. This is handled by the container runtime on a best effort basis.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"configureCbr0": {
							SchemaProps: spec.SchemaProps{
								Description: "configureCBR0 enables the kublet to configure cbr0 based on Node.Spec.PodCIDR.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"hairpinMode": {
							SchemaProps: spec.SchemaProps{
								Description: "How should the kubelet configure the container bridge for hairpin packets. Setting this flag allows endpoints in a Service to loadbalance back to themselves if they should try to access their own Service. Values:\n  \"promiscuous-bridge\": make the container bridge promiscuous.\n  \"hairpin-veth\":       set the hairpin flag on container veth interfaces.\n  \"none\":               do nothing.\nSetting --configure-cbr0 to false implies that to achieve hairpin NAT one must set --hairpin-mode=veth-flag, because bridge assumes the existence of a container bridge named cbr0.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"babysitDaemons": {
							SchemaProps: spec.SchemaProps{
								Description: "The node has babysitter process monitoring docker and kubelet. Removed as of 1.7",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"maxPods": {
							SchemaProps: spec.SchemaProps{
								Description: "maxPods is the number of pods that can run on this Kubelet.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"nvidiaGPUs": {
							SchemaProps: spec.SchemaProps{
								Description: "nvidiaGPUs is the number of NVIDIA GPU devices on this node.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"podCIDR": {
							SchemaProps: spec.SchemaProps{
								Description: "The CIDR to use for pod IP addresses, only used in standalone mode. In cluster mode, this is obtained from the master.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"reconcileCIDR": {
							SchemaProps: spec.SchemaProps{
								Description: "reconcileCIDR is Reconcile node CIDR with the CIDR specified by the API server. No-op if register-node or configure-cbr0 is false.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"registerSchedulable": {
							SchemaProps: spec.SchemaProps{
								Description: "registerSchedulable tells the kubelet to register the node as schedulable. No-op if register-node is false.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"resolvConf": {
							SchemaProps: spec.SchemaProps{
								Description: "ResolverConfig is the resolver configuration file used as the basis for the container DNS resolution configuration.\"), []",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"nodeLabels": {
							SchemaProps: spec.SchemaProps{
								Description: "nodeLabels to add when registering the node in the cluster.",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"nonMasqueradeCIDR": {
							SchemaProps: spec.SchemaProps{
								Description: "nonMasqueradeCIDR configures masquerading: traffic to IPs outside this range will use IP masquerade.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"enableCustomMetrics": {
							SchemaProps: spec.SchemaProps{
								Description: "enable gathering custom metrics.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"networkPluginMTU": {
							SchemaProps: spec.SchemaProps{
								Description: "networkPluginMTU is the MTU to be passed to the network plugin, and overrides the default MTU for cases where it cannot be automatically computed (such as IPSEC).",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"imageGCHighThresholdPercent": {
							SchemaProps: spec.SchemaProps{
								Description: "imageGCHighThresholdPercent is the percent of disk usage after which image garbage collection is always run.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"imageGCLowThresholdPercent": {
							SchemaProps: spec.SchemaProps{
								Description: "imageGCLowThresholdPercent is the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"evictionHard": {
							SchemaProps: spec.SchemaProps{
								Description: "Comma-delimited list of hard eviction expressions.  For example, 'memory.available<300Mi'.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"evictionSoft": {
							SchemaProps: spec.SchemaProps{
								Description: "Comma-delimited list of soft eviction expressions.  For example, 'memory.available<300Mi'.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"evictionSoftGracePeriod": {
							SchemaProps: spec.SchemaProps{
								Description: "Comma-delimited list of grace periods for each soft eviction signal.  For example, 'memory.available=30s'.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"evictionPressureTransitionPeriod": {
							SchemaProps: spec.SchemaProps{
								Description: "Duration for which the kubelet has to wait before transitioning out of an eviction pressure condition.",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
						"evictionMaxPodGracePeriod": {
							SchemaProps: spec.SchemaProps{
								Description: "Maximum allowed grace period (in seconds) to use when terminating pods in response to a soft eviction threshold being met.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"evictionMinimumReclaim": {
							SchemaProps: spec.SchemaProps{
								Description: "Comma-delimited list of minimum reclaims (e.g. imagefs.available=2Gi) that describes the minimum amount of resource the kubelet will reclaim when performing a pod eviction if that resource is under pressure.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"volumePluginDirectory": {
							SchemaProps: spec.SchemaProps{
								Description: "The full path of the directory in which to search for additional third party volume plugins",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"taints": {
							SchemaProps: spec.SchemaProps{
								Description: "Taints to add when registering a node in the cluster",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"featureGates": {
							SchemaProps: spec.SchemaProps{
								Description: "FeatureGates is set of key=value pairs that describe feature gates for alpha/experimental features.",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.KubenetNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "KubenetNetworkingSpec is the specification for kubenet networking, largely integrated but intended to replace classic",
					Properties:  map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.KuberouterNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "Kuberouter declares that we want Canal networking",
					Properties:  map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.LeaderElectionConfiguration": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "LeaderElectionConfiguration defines the configuration of leader election clients for components that can run with leader election enabled.",
					Properties: map[string]spec.Schema{
						"leaderElect": {
							SchemaProps: spec.SchemaProps{
								Description: "leaderElect enables a leader election client to gain leadership before executing the main loop. Enable this when running replicated components for high availability.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.LoadBalancerAccessSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"type": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"idleTimeoutSeconds": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int64",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.NetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "NetworkingSpec allows selection and configuration of a networking plugin",
					Properties: map[string]spec.Schema{
						"classic": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.ClassicNetworkingSpec"),
							},
						},
						"kubenet": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.KubenetNetworkingSpec"),
							},
						},
						"external": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.ExternalNetworkingSpec"),
							},
						},
						"cni": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.CNINetworkingSpec"),
							},
						},
						"kopeio": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.KopeioNetworkingSpec"),
							},
						},
						"weave": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.WeaveNetworkingSpec"),
							},
						},
						"flannel": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.FlannelNetworkingSpec"),
							},
						},
						"calico": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.CalicoNetworkingSpec"),
							},
						},
						"canal": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.CanalNetworkingSpec"),
							},
						},
						"kuberouter": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha2.KuberouterNetworkingSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha2.CNINetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha2.CalicoNetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha2.CanalNetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha2.ClassicNetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha2.ExternalNetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha2.FlannelNetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha2.KopeioNetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha2.KubenetNetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha2.KuberouterNetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha2.WeaveNetworkingSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.RBACAuthorizationSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.TopologySpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"masters": {
							SchemaProps: spec.SchemaProps{
								Description: "The environment to launch the Kubernetes masters in public|private",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"nodes": {
							SchemaProps: spec.SchemaProps{
								Description: "The environment to launch the Kubernetes nodes in public|private",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"bastion": {
							SchemaProps: spec.SchemaProps{
								Description: "Bastion provide an external facing point of entry into a network containing private network instances. This host can provide a single point of fortification or audit and can be started and stopped to enable or disable inbound SSH communication from the Internet, some call bastion as the \"jump server\".",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha2.BastionSpec"),
							},
						},
						"dns": {
							SchemaProps: spec.SchemaProps{
								Description: "DNS configures options relating to DNS, in particular whether we use a public or a private hosted zone",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha2.DNSSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha2.BastionSpec", "k8s.io/kops/pkg/apis/kops/v1alpha2.DNSSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha2.WeaveNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "Weave declares that we want Weave networking",
					Properties: map[string]spec.Schema{
						"mtu": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int32",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
	}
}
